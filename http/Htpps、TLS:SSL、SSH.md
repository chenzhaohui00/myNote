### Htpps

http请求都是分为一个client/browser，一个server，c/b向s发送请求。通常是c/b要确认s的身份，避免访问一个假的服务器或者中间人。而使用Https建立加密通信的过程，就是先通过TLS的数字证书技术确认了server端的身份。后续的通信就安全了。

而后面一般服务器要再验证c/b是谁，则是通过建立在https的安全通信基础上的账号系统，让c/b通过帐户密码进行登录，或已经登录过的token来验证c/b的身份了。



### TLS/SSL

首先，TLS和SSL是同一套协议的不同版本，SSL是前面的协议，在3.0以后的后续版本改成了TLS。

TLS/SSL 是一个在Socket层以上、应用层以下的加密技术，用来给应用层的一些通信协议比如Http，Ftp等提供加密的技术。

他们包含从c/b端发送一个Client Hello开始，到双方得到对称加密密钥进行通信结束。



### TLS/SSL的过程

主要取自[这篇知乎文章](https://zhuanlan.zhihu.com/p/75461564)，有很详细的一个https的建立过程。

1. Client Hello，主要是携带自己使用的TLS版本、支持的加密套件和一个随机数1。
2. Server Hello，会包含几个部分数据：
   1. 服务器会在c/b发过来的加密套件中选择使用的一个加密套件
   2. 几个ca证书
   3. 一个随机数2。
3. c/b端验证Server Hello发过来的证书
4. 验证通过后，c/b端根据前面Client Hello中的随机数1、Server Hello中的随机数2和再生成的随机数3生成对称加密的密钥，发送给s端。
5. 双方可以使用对称加密的密钥通信。



### c/b端如何验证s端的证书

Server Hello中会有多个CA证书，比如有四个，那么第一个证书是s端自己的证书，第二个证书是给s端签名的ca的证书，第三个证书是给第二个ca机构签名的ca的证书，第四个证书是给第三个ca机构签名的root ca证书。第四个root证书是内置在系统内的，我们信任的。

具体验证一个证书，要通过这个证书内的信息摘要、数据签名、签名算法以及给他签名的ca证书的公钥来验证，整体的验证思路可以看[码农翻身的https文章的博客](https://blog.csdn.net/coderising/article/details/100021384)，具体的验证过程在上面提到过的[这篇知乎文章](https://zhuanlan.zhihu.com/p/75461564)中有详细举例。

还是自己叙述一下验证的思路和一些细节吧，首先签名的操作，其实就是CA用他自己的私钥通过一个加密算法对一个证书的摘要hash进行加密的过程，把这个hash加密后变成了一个新的加密后的串，也就是证书签名了。而被加密的hash，是证书信息摘要通过openssl等库计算出的hash值，这个摘要包含了证书签发机构、证书有效期、这个证书是给哪个网站签发的（也就是域名）等信息。

所以，整体流程就是我们有了要访问的网站的证书和给它签发证书的ca机构的证书，就用ca的公钥使用证书中的签名算法对被签名过的证书签名进行解密，就能得到证书的摘要hash，然后再对证书内的信息摘要通过openssl库进行加密计算出摘要hash，对比这两个hash，如果完全一致就说明没问题。这时候就验证的确是这个ca给这个网站做的签名。

那ca的身份怎么验证呢，就用给它签发的证书验证它的身份，用上面同样的方法再做一次。最后我们会用一个root ca证书验证，这样所有的信息就都是可信的了。当然，在确认了s端的证书是未被篡改的以后，还要验证其中的域名是否正确、证书时间是否过期等问题。再验证通过了才说明这个证书完全ok。



### SSH

这个就是通常我们远程登录使用的技术，不会用到TLS/SSL技术，它其实就是c/b提前把自己的公钥放到s端上，然后等c/b要登录的时候，发自己的公钥过去，服务端找这个公钥就知道是谁要登录，然后会用找到的这个公钥加密一段数据（challenge）发给c/b端，c/b端用自己的私钥解密以后发回给c端，c端验证下是不是和自己加密的数据的原文一致。对上了就说明登录人持有私钥，可以给他登录。

#### 对SSH的一些思考：

1. 可以看到，SSH和Https相反，他是s端要验证c/b的身份，最适合的一个场景也就是远程登录了。
2. 之所以SSH不需要TLS那一套，是因为他是基于一个前提，就是前端可以先把自己的公钥正确地传输给后端，这样就不需要额外确认前端的身份，因为后端手里拿着绝对正确的前端的公钥，只要发一个challenge数据，前端能通过，就说明他是他了。

