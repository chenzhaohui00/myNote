问题：

有段代码有个bug，看半天没看出来问题在哪。就是他先去网络上获取数据，然后更新到数据库。在从数据库取出来。神奇的是，网络回来了15条，然后从数据库一取，发现变成45条了。所有数据都存了三遍。

结果：

多次执行的问题，这段代码是从一个Fragment中执行的，然后到了Presenter，到了Model。问题是这个Fragment在一个activity中有三份。同一时间走了三次，由于网络请求和结果处理以及数据库的操作都是在io线程，就直接往里面插了三份数据。

思考：

1. 这说明他Presenter里直接做这个网络请求其实是容易出问题的，应该在后面再抽一个比如UserCase层，然后把请求放到里面，考虑把这个UserCase层每个对象做成单例的，然后里面对每个请求加一个id，请求之前，先检查是否有相同id的结果在请求，如果在请求，就可以有两种处理策略，或者把这个请求丢弃，或者考虑把回调的callback存起来，等那个相同id的请求回来了一起回调。
2. 除了上述方法，还可以直接做好数据库insert时的去重。但是目前我还不太会用去重，这次遇到这个问题也尝试了添加onConflact的策略为replace，而且存储的时候对象只有一个自增的主键未赋值，其余属性全都一致，也添加了equals方法，但是还是不管用，依然可以存储重复的对象，或者说room不认为这是一个重复的对象。