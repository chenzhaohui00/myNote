## 业务接口参数检查问题

由于offline first app需要对很多访问后端的业务请求做对应的本地话的存储，用户在offline时做了操作，我们就会存储起来，在用户online的时候去访问后端再更新本地数据库。

对于用户来说，他操作的时候就要确保这个操作是正确的，所以这些请求在后端那边做的参数检查，在移动端也要做一次，否则就会发生一种情况：用户offline的时候操作成功了，等用户online的时候请求后端，然后后端报错了。这时就很尴尬了，如果处理的不好，会发现这个上传任务一直不成功，用户本地有数据，一直传不到后端。即使可以重新修改之前的操作数据，但是可能用户已经脱离了业务操作的场景了，你让他重新改，他未必能改得了，原来的数据可能已经忘了。



## 数据同步的问题

要考虑数据是否是只有移动端才能生成和修改的，如果多端都可以修改，需要好好设计这个同步问题。发生冲突时多端如何同步数据。如果出现了无法同步的问题，是否有一个方式，强行同步到正确的数据。



## 网络层错误处理问题

以前网络层的错误会直接暴露在`ViewModel`层或者`Presenter`层，比如进行一次网络请求发生了htpp的error，直接在这一层做一个htpp错误的可观察数据，然后在View层观察并且处理就好了，比如401就做跳转登录页的操作，500就报服务器错误并且显示对应的error view。

但是对于OFA(offline first app)来说，在`ViewModel`层或者`Presenter`层中用的肯定是个基于数据库的repository，而这个repository后面才是一个处理网络和更新数据库的repository，那我们就无法像之前那么直观地做网络错误的观察和处理了。

那网络repository那层的错误如何传到view层呢？毕竟view需要做对应的处理，比如错误提示提醒用户某个数据没有同步上去或者仅仅是toast一下。另外网络respository中的错误还可能还需要传递到正确的页面，有些网络错误可能不需要在当前页面做处理。不要做错了提示。

目前想的解决方案，可能是在那个网络repository那层做一些全局的错误信息的可观察数据，分门别类地去做，每种错误有不同的可观察数据，然后不同的页面根据需要观察各自所需要观察的错误，有些错误可能一次就消耗掉的，也要在观察的同时由view层做消耗。



## 多个bean之间的转换很麻烦

离线优先app基本上要有三个bean层，一个是后端传来的bean层，一个db的bean层，一个是内存中使用的bean层。

意味着一个从后端拿的对象要转换两次才能使用。同样，一个内存中产生的bean，要转换两次才能给后端传递过去。

这个过程很容易出错，要小心处理，尽量把每个bean都做成充血模型，做好封装，注意代码复用。